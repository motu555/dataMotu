package process.others;import com.alibaba.fastjson.JSON;import com.alibaba.fastjson.serializer.SerializerFeature;import data.RecDish;import data.Review;import data.Shop;import org.ansj.domain.Term;import org.ansj.splitWord.analysis.ToAnalysis;import util.CompareDish;import util.FileOperation;import java.io.*;import java.util.*;import java.util.regex.Matcher;import java.util.regex.Pattern;/** * Created by wangkeqiang on 2016/4/9. * 输入文件： shopinfo.json * * 用于对菜品名中的停用词进行过滤的类 */public class DishesFilter_wkq {    public String cityCode;    public String cityDataPath;    final static String encoding = "UTF-8";    private int dishNumber = 0;    private int extentNumber = 0;    private int processNumber = 100000;    private int reviewNum = 0;    private StringBuilder jsonStr = new StringBuilder("");    private Set<String> dishAllSet;    public DishesFilter_wkq(String cityCodeParam, String dataPathParam) {        this.cityCode = cityCodeParam;        this.cityDataPath = dataPathParam + "/" + cityCode + "/";    }    /**     * count up the number of tags in the shop info and filter the number is less than countParam (such as 20)     * 1.输入shopInfo.json     * 2.统计tag在所有shop中出现的次数，排序     * 3.将tag按照在shop中出现的次数进行过滤     * 4.输出所有tags按次数排序后的文件shopTagsSort.txt， 输出tag按出现次数过滤后的文件shopTags.txt     * 注：餐厅的tags中会夹杂很多菜名     * @param countParam     */    public void getShopTags(int countParam) {        String fileName = this.cityDataPath + "shopInfo.json";        Set<String> tagSet = new HashSet<>();        String read;        FileInputStream file;        BufferedReader bufferedReader;        try {            file = new FileInputStream(fileName);            bufferedReader = new BufferedReader(new InputStreamReader(file, encoding));            while ((read = bufferedReader.readLine()) != null) {                Shop shop = JSON.parseObject(read, Shop.class);                if (shop.getTags() != null) {                    for (String tag : shop.getTags()) {                        tagSet.add(tag);                    }                }            }            bufferedReader.close();        } catch (FileNotFoundException e) {            e.printStackTrace();        } catch (UnsupportedEncodingException e) {            e.printStackTrace();        } catch (IOException e) {            e.printStackTrace();        }////        StringBuilder tagStr = new StringBuilder("");//        for (String tag : tagSet) {//            tagStr.append(tag);//            tagStr.append("\n");//        }//        FileOperation.writeNotAppdend(this.cityDataPath + "shopTags.txt", tagStr.toString());        Map<String, Integer> tagMap = new HashMap<>();        for (String tag : tagSet) {            tagMap.put(tag, 0);        }        try {            file = new FileInputStream(fileName);            bufferedReader = new BufferedReader(new InputStreamReader(file, encoding));            while ((read = bufferedReader.readLine()) != null) {                Shop shop = JSON.parseObject(read, Shop.class);                if (shop.getTags() != null) {                    for (String tag : shop.getTags()) {                        tagMap.put(tag, tagMap.get(tag) + 1);                    }                }            }            bufferedReader.close();        } catch (FileNotFoundException e) {            e.printStackTrace();        } catch (UnsupportedEncodingException e) {            e.printStackTrace();        } catch (IOException e) {            e.printStackTrace();        }        List<RecDish> tagList = new ArrayList<>();        for (Map.Entry<String, Integer> entry : tagMap.entrySet()) {            tagList.add(new RecDish(entry.getKey(), entry.getValue()));        }        Comparator<RecDish> RecDishCompare = new CompareDish();        Collections.sort(tagList, RecDishCompare);        StringBuilder dishStr = new StringBuilder("");        for (RecDish rd : tagList) {            dishStr.append(rd.getDish());            dishStr.append("\t");            dishStr.append(rd.getNumber());            dishStr.append("\n");        }        FileOperation.writeNotAppdend(this.cityDataPath + "shopTagsSort.txt", dishStr.toString());        dishStr = new StringBuilder("");        for (RecDish rd : tagList) {            if (rd.getNumber() >= countParam) {                dishStr.append(rd.getDish());                dishStr.append("\n");            }        }        FileOperation.writeNotAppdend(this.cityDataPath + "shopTags.txt", dishStr.toString());    }    /**     *对菜名进行停用词过滤的类     * 调用方式： df.dishWordFilter("dishNumberAllExtendFilter.txt","dishFinal.txt");     * 1.输入dishNumberAllExtendFilter.txt， 菜名待过滤的列表  109138个菜     * 2. 输出过滤后最终得到的菜名列表dishFinal.txt  108923个菜     * @param dishName     * @param storeName     */    public void dishWordFilter(String dishName, String storeName) {        List<String> dishSortList = FileOperation.readLineArrayList(this.cityDataPath + dishName);        //这里的shopTags.txt是过滤后的餐厅tag, 主要是餐厅功能的tag,不包含菜名        Set<String> shopTagSet = FileOperation.readLineSet(this.cityDataPath + "shopTags.txt");        //通用的停用词表        List<String> stopWords = FileOperation.readLineArrayList("stopLibrary.dic");        StringBuilder dishStr = new StringBuilder("");        /**         * 手动构建的专门针对菜名的停用词表         */        Set<String> stopEqualSet = FileOperation.readLineSet("stopEqual.txt", encoding);//        for(String temp:stopEqualSet){//            System.out.println(temp+" "+temp.length());//        }//        if(stopEqualSet.contains("新鲜")){//            System.out.println("新鲜");//        }        for (String temp : dishSortList) {            /**             * 先用菜名专用的停用词表过滤一次             */            if (temp.endsWith("类") || temp.endsWith("了") || temp.endsWith("辣")) {                continue;            }            if (stopEqualSet.contains(temp)) {//                System.out.println(temp);                continue;            }            if (isChineseChar(temp) == 0) {                if (temp.length() > 1 && temp.length() < 11) {                    /**                     * 1. 如果菜名不在标签集合中【因为观察到菜名可能与tag有重合，需要过滤掉】                     * 2. 菜名如果包含停用词需要过滤掉                     */                    if (!shopTagSet.contains(temp)) {                        boolean judge = true;                        for (String stop : stopWords) {                            if (temp.contains(stop)) {                                judge = false;                                break;                            }                        }                        if (judge) {                            dishStr.append(temp);                            dishStr.append("\n");                        }                    }                }            }        }        FileOperation.writeNotAppdend(this.cityDataPath + storeName, dishStr.toString());    }    public int isChineseChar(String str) {        Pattern p = Pattern.compile("[^\u4e00-\u9fa5]");        Matcher m = p.matcher(str);        if (m.find()) {//            System.out.println(m.replaceAll(""));            return m.toString().length();        }        return 0;    }    /**     * 调用方式 df.dishCountFilter(2, "dishFilterWord.txt");     * 1.对dishFilterWord.txt中的菜，到review.json和review_filter.json中     * 统计他们在review的favDishes字段出现的字数     * 2.按出现次数排序后写入dishNumberSortFilter.txt     * 3.按出现次数大于一定值过滤后写入dishNumberFilter.txt     * @param number     * @param dishFile     */    public void dishCountFilter(int number, String dishFile) {        String reviewJsonFile = this.cityDataPath + "reviews.json"; //非水贴源文件        String reviewFilterJsonFile = this.cityDataPath + "review_filter.json"; //水贴源文件        String dishFilterPath = this.cityDataPath + dishFile;        String encoding = "UTF-8";        Map<String, Integer> dishMap = new HashMap<>();        Set<String> dishSet = FileOperation.readLineSet(dishFilterPath);        for (String dish : dishSet) {            dishMap.put(dish, 0);        }        String read;        FileInputStream file;        BufferedReader bufferedReader;        Review rev;        int count = 0;        try {            file = new FileInputStream(reviewJsonFile);            bufferedReader = new BufferedReader(new InputStreamReader(file, encoding));            while ((read = bufferedReader.readLine()) != null) {                rev = JSON.parseObject(read, Review.class);                if (rev.getFavDishes() != null) {                    for (String dish : rev.getFavDishes()) {                        if (dishMap.containsKey(dish)) {                            dishMap.put(dish, dishMap.get(dish) + 1);                        }                    }                }                count++;                if (count % 1000000 == 0) {                    System.out.println("Count up " + count + "th reviews " + new Date());                }            }            bufferedReader.close();        } catch (FileNotFoundException e) {            e.printStackTrace();        } catch (UnsupportedEncodingException e) {            e.printStackTrace();        } catch (IOException e) {            e.printStackTrace();        }        try {            file = new FileInputStream(reviewFilterJsonFile);            bufferedReader = new BufferedReader(new InputStreamReader(file, encoding));            while ((read = bufferedReader.readLine()) != null) {                rev = JSON.parseObject(read, Review.class);                if (rev.getFavDishes() != null) {                    for (String dish : rev.getFavDishes()) {                        if (dishMap.containsKey(dish)) {                            dishMap.put(dish, dishMap.get(dish) + 1);                        }                    }                }                count++;                if (count % 1000000 == 0) {                    System.out.println("Count up " + count + "th reviews " + new Date());                }            }            bufferedReader.close();        } catch (FileNotFoundException e) {            e.printStackTrace();        } catch (UnsupportedEncodingException e) {            e.printStackTrace();        } catch (IOException e) {            e.printStackTrace();        }        List<RecDish> dishesList = new ArrayList<>();        for (Map.Entry<String, Integer> temp : dishMap.entrySet()) {            dishesList.add(new RecDish(temp.getKey(), temp.getValue()));        }        Comparator<RecDish> RecDishCompare = new CompareDish();        Collections.sort(dishesList, RecDishCompare);        StringBuilder dishStrNumber = new StringBuilder("");        StringBuilder dishStr = new StringBuilder("");        for (RecDish rd : dishesList) {            dishStrNumber.append(rd.getDish());            dishStrNumber.append("\t");            dishStrNumber.append(rd.getNumber());            dishStrNumber.append("\n");            if (rd.getNumber() > number) {                dishStr.append(rd.getDish());                dishStr.append("\n");            }        }        FileOperation.writeNotAppdend(this.cityDataPath + "dishNumberSortFilter.txt", dishStrNumber.toString());        FileOperation.writeNotAppdend(this.cityDataPath + "dishNumberFilter.txt", dishStr.toString());    }    /**     *  调用方式： df.dishExtendAll("dishFinal.txt", "allReviewExtend.json");     * @param dishFile     * @param storeFile     */    public void dishExtendAll(String dishFile, String storeFile) {        this.dishAllSet = FileOperation.readLineSet(this.cityDataPath + dishFile);        this.dishExtendFilter(storeFile);        this.dishExtend(storeFile);        if (reviewNum % processNumber != 0) {            FileOperation.writeAppdend(this.cityDataPath + storeFile, this.jsonStr.toString());        }        System.out.println("Extend " + reviewNum + "th reviews " + " Dishes Number: " + dishNumber + " Extend Number: " + extentNumber + "\t" + new Date());    }    public void dishExtend(String storeFile) {        String fileName = cityDataPath + "reviews.json";        String read = null;        FileInputStream file = null;        BufferedReader bufferedReader = null;        Review rev;        try {            file = new FileInputStream(fileName);            bufferedReader = new BufferedReader(new InputStreamReader(file));            while ((read = bufferedReader.readLine()) != null) {                rev = JSON.parseObject(read, Review.class);                this.jsonStr.append(this.dishExtend(rev));                this.jsonStr.append("\n");                reviewNum++;                if (reviewNum % processNumber == 0) {                    System.out.println("Extend " + reviewNum + "th reviews " + " Dishes Number: " + dishNumber + " Extend Number: " + extentNumber + "\t" + new Date());                    FileOperation.writeAppdend(this.cityDataPath + storeFile, this.jsonStr.toString());                    this.jsonStr = new StringBuilder("");                }            }            bufferedReader.close();        } catch (FileNotFoundException e) {            e.printStackTrace();        } catch (UnsupportedEncodingException e) {            e.printStackTrace();        } catch (IOException e) {            e.printStackTrace();        }    }    public void dishExtendFilter(String storeFile) {        String fileName = this.cityDataPath + "review_filter.json";        String read = null;        FileInputStream file = null;        BufferedReader bufferedReader = null;        Review rev;        try {            file = new FileInputStream(fileName);            bufferedReader = new BufferedReader(new InputStreamReader(file));            while ((read = bufferedReader.readLine()) != null) {                rev = JSON.parseObject(read, Review.class);                this.jsonStr.append(this.dishExtend(rev));                this.jsonStr.append("\n");                reviewNum++;                if (reviewNum % processNumber == 0) {                    System.out.println("Extend " + reviewNum + "th reviews " + " Dishes Number " + dishNumber + " Extend Number: " + extentNumber + "\t" + new Date());                    FileOperation.writeAppdend(this.cityDataPath + storeFile, this.jsonStr.toString());                    this.jsonStr = new StringBuilder("");                }            }            bufferedReader.close();        } catch (FileNotFoundException e) {            e.printStackTrace();        } catch (UnsupportedEncodingException e) {            e.printStackTrace();        } catch (IOException e) {            e.printStackTrace();        }    }    public String dishExtend(Review review) {        Review re = new Review();        re.setShopId(review.getShopId());        re.setUserId(review.getUserId());//        System.out.println(JSON.toJSONString(review,SerializerFeature.SortField));        //这里用的是中文分词工具 ansj        List<Term> termList = ToAnalysis.parse(review.getText());        Set<String> dishOneReviewSet = new HashSet<>();        if (review.getFavDishes() != null) {            for (String dish : review.getFavDishes()) {                if (this.dishAllSet.contains(dish))                    dishOneReviewSet.add(dish);            }        }        dishNumber += dishOneReviewSet.size();        for (Term term : termList) {            if (this.dishAllSet.contains(term.getName())) {                dishOneReviewSet.add(term.getName());            }        }        extentNumber += dishOneReviewSet.size();        if (dishOneReviewSet.size() == 0) {            dishOneReviewSet = null;        }        re.setFavDishes(dishOneReviewSet);        re.setTaste(review.getTaste());        re.setCondition(review.getCondition());        re.setService(review.getService());        String jsonString = JSON.toJSONString(re, SerializerFeature.SortField);        return jsonString;    }    /**     * 调用方式：df.dishCountFilter2(2,"dishNumberFilter.txt");     * 1.统计dishNumberFilter.txt中的菜在FavDishes.json中出现的次数     * 2.按次数排序后得到dishNumberSortAllExtendFilter.txt   109138     * 3.按次数排序大于一定值过滤后得到dishNumberAllExtendFilter.txt   109138     * @param number     * @param dishFile     */    public void dishCountFilter2(int number, String dishFile) {        String reviewJsonFile = this.cityDataPath + "FavDishes.json";        String dishFilterPath = this.cityDataPath + dishFile;        String encoding = "UTF-8";        Map<String, Integer> dishMap = new HashMap<>();        Set<String> dishSet = FileOperation.readLineSet(dishFilterPath);        for (String dish : dishSet) {            dishMap.put(dish, 0);        }        String read;        FileInputStream file;        BufferedReader bufferedReader;        Review rev;        int count = 0;        try {            file = new FileInputStream(reviewJsonFile);            bufferedReader = new BufferedReader(new InputStreamReader(file, encoding));            while ((read = bufferedReader.readLine()) != null) {                rev = JSON.parseObject(read, Review.class);                if (rev.getFavDishes() != null) {                    for (String dish : rev.getFavDishes()) {                        if (dishMap.containsKey(dish)) {                            dishMap.put(dish, dishMap.get(dish) + 1);                        }                    }                }                count++;                if (count % 1000000 == 0) {                    System.out.println("Count up " + count + "th reviews " + new Date());                }            }            bufferedReader.close();        } catch (FileNotFoundException e) {            e.printStackTrace();        } catch (UnsupportedEncodingException e) {            e.printStackTrace();        } catch (IOException e) {            e.printStackTrace();        }        List<RecDish> dishesList = new ArrayList<>();        for (Map.Entry<String, Integer> temp : dishMap.entrySet()) {            dishesList.add(new RecDish(temp.getKey(), temp.getValue()));        }        Comparator<RecDish> RecDishCompare = new CompareDish();        Collections.sort(dishesList, RecDishCompare);        StringBuilder dishStrNumber = new StringBuilder("");        StringBuilder dishStr = new StringBuilder("");        for (RecDish rd : dishesList) {            dishStrNumber.append(rd.getDish());            dishStrNumber.append("\t");            dishStrNumber.append(rd.getNumber());            dishStrNumber.append("\n");            if (rd.getNumber() > number) {                dishStr.append(rd.getDish());                dishStr.append("\n");            }        }        FileOperation.writeNotAppdend(this.cityDataPath + "dishNumberSortAllExtendFilter.txt", dishStrNumber.toString());        FileOperation.writeNotAppdend(this.cityDataPath + "dishNumberAllExtendFilter.txt", dishStr.toString());    }    /**     * 调用方式： df.onlyDish("dishFinal.txt");     * 输出格式{"shopId":"10005175","userId":"128646165","taste":4,"condition":4,"service":4,"favDishes":["原味章鱼烧"]}，只包含     * 用户对店的评分和喜欢的菜这些字段，不对favDishes字段进行填充     *     * TODO Notice: 这里的判断条件仅为dishFinal.txt中包含菜品即可，不使用shopDishes过滤     * 因为shopDishes是评论中的favDishes经过DishFinal过滤的，所以这里直接用DishFinal来过滤和用shopDishe应该是一样的结果     * @param dishFile     */    public void onlyDish(String dishFile) {        Set<String> dishSet = FileOperation.readLineSet(this.cityDataPath + dishFile);        String reviewJsonFile = this.cityDataPath + "reviews.json";        String reviewFilterJsonFile = this.cityDataPath + "review_filter.json";        String encoding = "UTF-8";        String read;        FileInputStream file;        BufferedReader bufferedReader;        Review rev;        int count = 0;        int noNum = 0;        StringBuilder jsonStr = new StringBuilder("");        try {            file = new FileInputStream(reviewJsonFile);            bufferedReader = new BufferedReader(new InputStreamReader(file, encoding));            while ((read = bufferedReader.readLine()) != null) {                rev = JSON.parseObject(read, Review.class);                Review tempRev = new Review();                Set<String> oneDishes = new HashSet<>();                if (rev.getFavDishes() != null) {                    for (String dish : rev.getFavDishes()) {                        if (dishSet.contains(dish)) {                            oneDishes.add(dish);                        }                    }                }                if (oneDishes.size() == 0) {                    oneDishes = null;                } else {                    noNum++;                }                //为空也会写入文件                tempRev.setFavDishes(oneDishes);                tempRev.setShopId(rev.getShopId());                tempRev.setUserId(rev.getUserId());                tempRev.setTaste(rev.getTaste());                tempRev.setService(rev.getService());                tempRev.setCondition(rev.getCondition());                jsonStr.append(JSON.toJSONString(tempRev, SerializerFeature.SortField));                jsonStr.append("\n");                count++;                if (count % 1000000 == 0) {                    FileOperation.writeAppdend(this.cityDataPath + "oneDishes.json", jsonStr.toString());                    jsonStr = new StringBuilder("");                    System.out.println("Count up " + count + "th reviews " + noNum + new Date());                }            }            bufferedReader.close();        } catch (FileNotFoundException e) {            e.printStackTrace();        } catch (UnsupportedEncodingException e) {            e.printStackTrace();        } catch (IOException e) {            e.printStackTrace();        }        try {            file = new FileInputStream(reviewFilterJsonFile);            bufferedReader = new BufferedReader(new InputStreamReader(file, encoding));            while ((read = bufferedReader.readLine()) != null) {                rev = JSON.parseObject(read, Review.class);                Review tempRev = new Review();                Set<String> oneDishes = new HashSet<>();                if (rev.getFavDishes() != null) {                    for (String dish : rev.getFavDishes()) {                        if (dishSet.contains(dish)) {                            oneDishes.add(dish);                        }                    }                }                if (oneDishes.size() == 0) {                    oneDishes = null;                } else {                    noNum++;                }                tempRev.setFavDishes(oneDishes);                tempRev.setShopId(rev.getShopId());                tempRev.setUserId(rev.getUserId());                tempRev.setTaste(rev.getTaste());                tempRev.setService(rev.getService());                tempRev.setCondition(rev.getCondition());                jsonStr.append(JSON.toJSONString(tempRev, SerializerFeature.SortField));                jsonStr.append("\n");                count++;                if (count % 1000000 == 0) {                    FileOperation.writeAppdend(this.cityDataPath + "oneDishes.json", jsonStr.toString());                    jsonStr = new StringBuilder("");                    System.out.println("Count up " + count + "th reviews " + noNum + new Date());                }            }            bufferedReader.close();        } catch (FileNotFoundException e) {            e.printStackTrace();        } catch (UnsupportedEncodingException e) {            e.printStackTrace();        } catch (IOException e) {            e.printStackTrace();        }        if (count % 1000000 != 0) {            FileOperation.writeAppdend(this.cityDataPath + "oneDishes.json", jsonStr.toString());        }        System.out.println("Count up " + count + "th reviews " + noNum + new Date());    }    /**     * 调用方式 df.getShopDishes("dishFinal.txt", "shopDishes.txt");     * 1.利用dishFinal.txt来得到最终的餐厅菜品列表     * 2.将review.json和reveiw_filter.json评论中存在的  favDishes 字段，用dishFinal过滤一遍，     * 得到shopDishes每个餐厅对应的菜品集合，达到了用停用词过滤后的效果     * 3.最终得到的shopDishes列表是reveiw.json和review_filter.json共同过滤后的结果     * @param dishFile     * @param storeShopDishFile     */    public void getShopDishes(String dishFile, String storeShopDishFile) {        Set<String> dishSet = FileOperation.readLineSet(this.cityDataPath + dishFile);        Map<String, Set<String>> shopDishSetMap = new HashMap<>();        String reviewJsonFile = this.cityDataPath + "reviews.json";        String reviewFilterJsonFile = this.cityDataPath + "review_filter.json";        String read;        FileInputStream file;        BufferedReader bufferedReader;        Review rev;        int count = 0;        //处理reviews.json        try {            file = new FileInputStream(reviewJsonFile);            bufferedReader = new BufferedReader(new InputStreamReader(file, encoding));            while ((read = bufferedReader.readLine()) != null) {                rev = JSON.parseObject(read, Review.class);                if (!shopDishSetMap.containsKey(rev.getShopId())) {                    shopDishSetMap.put(rev.getShopId(), new HashSet<>());                }                if (rev.getFavDishes() != null) {                    for (String dish : rev.getFavDishes()) {                        if (dishSet.contains(dish)) {                            shopDishSetMap.get(rev.getShopId()).add(dish);                        }                    }                }                count++;                if (count % 1000000 == 0) {                    System.out.println("Count up " + count + "th reviews " + new Date());                }            }            bufferedReader.close();        } catch (FileNotFoundException e) {            e.printStackTrace();        } catch (UnsupportedEncodingException e) {            e.printStackTrace();        } catch (IOException e) {            e.printStackTrace();        }        //处理review_filter.json        try {            file = new FileInputStream(reviewFilterJsonFile);            bufferedReader = new BufferedReader(new InputStreamReader(file, encoding));            while ((read = bufferedReader.readLine()) != null) {                rev = JSON.parseObject(read, Review.class);                if (!shopDishSetMap.containsKey(rev.getShopId())) {                    shopDishSetMap.put(rev.getShopId(), new HashSet<>());                }                if (rev.getFavDishes() != null) {                    for (String dish : rev.getFavDishes()) {                        if (dishSet.contains(dish)) {                            shopDishSetMap.get(rev.getShopId()).add(dish);                        }                    }                }                count++;                if (count % 1000000 == 0) {                    System.out.println("Count up " + count + "th reviews " + new Date());                }            }            bufferedReader.close();        } catch (FileNotFoundException e) {            e.printStackTrace();        } catch (UnsupportedEncodingException e) {            e.printStackTrace();        } catch (IOException e) {            e.printStackTrace();        }        StringBuilder shopDishStr = new StringBuilder("");        for (Map.Entry<String, Set<String>> temp : shopDishSetMap.entrySet()) {            shopDishStr.append(temp.getKey());            shopDishStr.append("\t");            for (String dish : temp.getValue()) {                shopDishStr.append(dish);                shopDishStr.append(" ");            }            shopDishStr.append("\n");        }        FileOperation.writeNotAppdend(this.cityDataPath + storeShopDishFile, shopDishStr.toString());    }    public Map<String, Set<String>> shopDishesMapAll;    /**     * 调用方式 df.dishExtendAllShop("dishFinal.txt", "shopReviewExtend.json", "shopDishes.txt");     *     * @param dishFile     * @param storeFile     * @param shopDishFile     */    public void dishExtendAllShop(String dishFile, String storeFile, String shopDishFile) {        this.shopDishesMapAll = new HashMap<>();        List<String> shopDishList = FileOperation.readLineArrayList(this.cityDataPath + shopDishFile);        for (String temp : shopDishList) {            temp = temp.trim();            String[] strs = temp.split("\t");            if (strs.length > 1) {                this.shopDishesMapAll.put(strs[0], new HashSet<>());                String[] dishes = strs[1].split(" ");                for (String dish : dishes) {                    if (dish.length() > 1) {                        this.shopDishesMapAll.get(strs[0]).add(dish);                    }                }            }else {                this.shopDishesMapAll.put(temp,new HashSet<>());            }        }//        this.shopDishesMapAll = new HashMap<>();        this.dishAllSet = FileOperation.readLineSet(this.cityDataPath + dishFile);        /**         *  得到每个店里有哪些菜后，去扩充review.json和review_filter.json         */        this.dishExtendFilterShop(storeFile);        this.dishExtendShop(storeFile);        if (reviewNum % processNumber != 0) {            FileOperation.writeAppdend(this.cityDataPath + storeFile, this.jsonStr.toString());        }        System.out.println("Extend " + reviewNum + "th reviews " + " Dishes Number: " + dishNumber + " Extend Number: " + extentNumber + "\t" + new Date());    }    public void dishExtendShop(String storeFile) {        //TODO 使用deduplicate版本        String fileName = cityDataPath + "reviews.json";        String read = null;        FileInputStream file = null;        BufferedReader bufferedReader = null;        Review rev;        try {            file = new FileInputStream(fileName);            bufferedReader = new BufferedReader(new InputStreamReader(file));            while ((read = bufferedReader.readLine()) != null) {                rev = JSON.parseObject(read, Review.class);                this.jsonStr.append(this.dishExtendShop(rev));                this.jsonStr.append("\n");                reviewNum++;                if (reviewNum % processNumber == 0) {                    System.out.println("Extend " + reviewNum + "th reviews " + " Dishes Number: " + dishNumber + " Extend Number: " + extentNumber + "\t" + new Date());                    FileOperation.writeAppdend(this.cityDataPath + storeFile, this.jsonStr.toString());                    this.jsonStr = new StringBuilder("");                }            }            bufferedReader.close();        } catch (FileNotFoundException e) {            e.printStackTrace();        } catch (UnsupportedEncodingException e) {            e.printStackTrace();        } catch (IOException e) {            e.printStackTrace();        }    }    public void dishExtendFilterShop(String storeFile) {        //TODO 使用deduplicate版本        String fileName = this.cityDataPath + "review_filter.json";        String read = null;        FileInputStream file = null;        BufferedReader bufferedReader = null;        Review rev;        try {            file = new FileInputStream(fileName);            bufferedReader = new BufferedReader(new InputStreamReader(file));            while ((read = bufferedReader.readLine()) != null) {                rev = JSON.parseObject(read, Review.class);                this.jsonStr.append(this.dishExtendShop(rev));                this.jsonStr.append("\n");                reviewNum++;                if (reviewNum % processNumber == 0) {                    System.out.println("Extend " + reviewNum + "th reviews " + " Dishes Number " + dishNumber + " Extend Number: " + extentNumber + "\t" + new Date());                    FileOperation.writeAppdend(this.cityDataPath + storeFile, this.jsonStr.toString());                    this.jsonStr = new StringBuilder("");                }            }            bufferedReader.close();        } catch (FileNotFoundException e) {            e.printStackTrace();        } catch (UnsupportedEncodingException e) {            e.printStackTrace();        } catch (IOException e) {            e.printStackTrace();        }    }    /**     * 现在的逻辑是如果有favDishes字段，则直接提取出来     * 如果没有这个字段，则从评论文本中找，如果评论文本中提到了这家店的菜，同样提取出来     * 最终得到的数据格式，一条评论中包含如下字段：     * {"shopId":"10004038","userId":"5229029","taste":4,"condition":4,"service":4,"favDishes":["血糯米奶茶"]}     *     * TODO 修改代码     * 1.当前做法有噪音，只要text包含就增加上不太合理     * 2.结合review中的打分来约束，暂选taste这个打分，高于3分才算     * @param review     * @return     */    public String dishExtendShop(Review review) {        Review re = new Review();        re.setShopId(review.getShopId());        re.setUserId(review.getUserId());//        System.out.println(JSON.toJSONString(review,SerializerFeature.SortField));        List<Term> termList = ToAnalysis.parse(review.getText());        //记录一条评论中涉及到的菜品集合        Set<String> dishOneReviewSet = new HashSet<>();        /**         * 从favDishes字段中提取菜品，利用shopDishesMapAll进行过滤         * 因为shopDishesMapAll中的菜名已经是经过停用词过滤后的了         */        if (review.getFavDishes() != null) {            for (String dish : review.getFavDishes()) {                if (this.shopDishesMapAll.get(review.getShopId()).contains(dish))                    dishOneReviewSet.add(dish);            }        }        /**         *  dishNumber记录的是本身favDishes字段中包含的菜的数量，也就粗略对应着         *  本身<user-shop-favPair>的个数</>         */        dishNumber += dishOneReviewSet.size();//        System.out.println(review.getShopId());        /**         * 从评论文本中提取         */        for (Term term : termList) {            if (this.shopDishesMapAll.get(review.getShopId()).contains(term.getName())) {                dishOneReviewSet.add(term.getName());            }        }        /**         *  extentNumber记录的是评论中提取的菜的数量，也就粗略对应着         *  扩充的<user-shop-textDish>的个数</>         */        extentNumber += dishOneReviewSet.size();        if (dishOneReviewSet.size() == 0) {            dishOneReviewSet = null;        }        /**         * 可能提取不到，该字段为空         */        re.setFavDishes(dishOneReviewSet);        re.setTaste(review.getTaste());        re.setCondition(review.getCondition());        re.setService(review.getService());        String jsonString = JSON.toJSONString(re, SerializerFeature.SortField);        return jsonString;    }    /**     * 1. shopReviewExtend.json是reveiw.json和reviewFilter.json中的favDishes字段经过填充后得到的结果     * @param args     */    public static void main(String[] args) {//        String dataPath = "F:/datasets/dianping";//        String cityCode = "1";//        String dataPath = "D:/Data/OriginData/wkq_DianpingData/2";//        String cityCode = "2";        String dataPath = "D:/Data/OriginData/wkq_DianpingData/2";        String cityCode = "2";        DishesFilter_wkq df = new DishesFilter_wkq(cityCode, dataPath);        //得到过滤后的餐厅tag集合        df.getShopTags(20);        //将菜名按停用词等规则进行过滤，得到最终的菜名列表        df.dishWordFilter("dishNumberAllExtendFilter.txt","dishFinal.txt");        //将dishFilterWord.txt按照其在review中的出现次数进行排序和过滤        df.dishCountFilter(2, "dishFilterWord.txt");        //利用dishFinal.txt把review.json和reviewFilter.json中每条评论favDishes中的菜品过滤出来，写入文件        df.onlyDish("dishFinal.txt");        /**         * 区分df.dishExtendAll和dishExtendAllShop         * dishExtendAll会把评论文本中不是这家店的菜也包含进去，噪音更大         */        df.dishExtendAll("dishFinal.txt", "allReviewExtend.json");        //统计dishNumberFilter.txt中的菜在FavDishes.json中出现的次数,按阀值进行过滤        df.dishCountFilter2(2,"dishNumberFilter.txt");        df.getShopDishes("dishFinal.txt", "shopDishes.txt");        df.dishExtendAllShop("dishFinal.txt", "shopReviewExtend.json", "shopDishes.txt");    }}